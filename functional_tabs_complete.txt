with tab7:
    st.header("Gestión")
    
    # Sistema de autenticación
    if 'authenticated_gerencial' not in st.session_state:
        st.session_state.authenticated_gerencial = False
    
    if not st.session_state.authenticated_gerencial:
        st.info("Esta sección requiere autenticación")
        
        col1, col2, col3 = st.columns([1, 2, 1])
        with col2:
            password_input = st.text_input(
                "Contraseña:", 
                type="password",
                key="password_gerencial"
            )
            
            col_btn1, col_btn2 = st.columns(2)
            with col_btn1:
                if st.button("Ingresar", type="primary", use_container_width=True):
                    # Contraseña
                    if password_input == "maxisalas":
                        st.session_state.authenticated_gerencial = True
                        st.rerun()
                    else:
                        st.error("Contraseña incorrecta")
            
            with col_btn2:
                if st.button("Cancelar", use_container_width=True):
                    st.session_state.password_gerencial = ""
        
        
    else:
        # Botón de logout
        col1, col2, col3 = st.columns([4, 1, 1])
        with col3:
            if st.button("Cerrar sesión"):
                st.session_state.authenticated_gerencial = False
                st.rerun()
        
        st.success("Acceso autorizado")
        
        # Mostrar estado de filtros aplicados
        st.subheader("Estado de filtros aplicados")
        
        # Crear un resumen visual de los filtros activos
        filtros_activos = []
        if efector_seleccionado != 'Todos':
            filtros_activos.append(f"**Hospital/CAPS:** {efector_seleccionado}")
        if area_seleccionada != 'Todas':
            filtros_activos.append(f"**Área:** {area_seleccionada}")
        if dia_seleccionado != 'Todos':
            filtros_activos.append(f"**Día:** {dia_seleccionado}")
        if tipo_turno_seleccionado != 'Todos':
            filtros_activos.append(f"**Tipo de agenda:** {tipo_turno_seleccionado}")
        
        if filtros_activos:
            st.info("**Filtros activos desde la barra lateral:**\n\n" + " • ".join(filtros_activos))
        else:
            st.info("**Mostrando todos los datos** (sin filtros aplicados)")
        
        # Filtro adicional específico para gestión
        st.subheader("Filtro adicional de gestión")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            # Filtro por médico específico (usando datos ya filtrados)
            medicos_gerencial = ['Todos'] + sorted(df_filtrado[df_filtrado['doctor'] != 'Sin asignar']['doctor'].unique().tolist())
            medico_gerencial = st.selectbox(
                "Médico específico:",
                medicos_gerencial,
                key="medico_gerencial",
                help="Filtro adicional que se aplica sobre los filtros de la barra lateral"
            )
        
        with col2:
            # Mostrar estadísticas de los datos filtrados
            total_registros_filtrados = len(df_filtrado)
            medicos_disponibles = len(medicos_gerencial) - 1  # -1 para excluir "Todos"
            st.metric("Registros filtrados", f"{total_registros_filtrados:,}")
        
        with col3:
            st.metric("Médicos disponibles", f"{medicos_disponibles:,}")
        
        # Aplicar filtro adicional de médico específico a los datos ya filtrados
        df_gerencial = df_filtrado.copy()
        
        if medico_gerencial != 'Todos':
            df_gerencial = df_gerencial[df_gerencial['doctor'] == medico_gerencial]
            st.success(f"Análisis enfocado en: **{medico_gerencial}**")
        
        # NUEVA FUNCIONALIDAD: Análisis de superposición de horarios
        st.markdown("---")
        st.subheader("Superposición de horarios")
        
        def detectar_superposiciones(df_analisis):
            """Detecta médicos con horarios superpuestos"""
            superposiciones = []
            
            # Agrupar por médico
            medicos_horarios = df_analisis[df_analisis['doctor'] != 'Sin asignar'].groupby('doctor')
            
            for medico, datos_medico in medicos_horarios:
                # Convertir horas a formato datetime para comparación
                datos_medico = datos_medico.copy()
                datos_medico['hora_inicio_dt'] = pd.to_datetime(datos_medico['hora_inicio'], format='%H:%M', errors='coerce')
                datos_medico['hora_fin_dt'] = pd.to_datetime(datos_medico['hora_fin'], format='%H:%M', errors='coerce')
                
                # Agrupar por día
                dias_medico = datos_medico.groupby('dia')
                
                for dia, horarios_dia in dias_medico:
                    horarios_dia = horarios_dia.sort_values('hora_inicio_dt')
                    
                    # Comparar horarios del mismo día
                    for i, (idx1, row1) in enumerate(horarios_dia.iterrows()):
                        for idx2, row2 in horarios_dia.iloc[i+1:].iterrows():
                            # Verificar superposición
                            if (row1['hora_inicio_dt'] < row2['hora_fin_dt'] and 
                                row1['hora_fin_dt'] > row2['hora_inicio_dt']):
                                
                                superposiciones.append({
                                    'medico': medico,
                                    'dia': dia,
                                    'centro_1': row1['efector'],
                                    'area_1': row1['area'],
                                    'horario_1': f"{row1['hora_inicio']} - {row1['hora_fin']}",
                                    'tipo_agenda_1': row1['tipo_turno'],
                                    'centro_2': row2['efector'],
                                    'area_2': row2['area'],
                                    'horario_2': f"{row2['hora_inicio']} - {row2['hora_fin']}",
                                    'tipo_agenda_2': row2['tipo_turno'],
                                    'tipo_conflicto': 'Mismo centro' if row1['efector'] == row2['efector'] else 'Centros diferentes'
                                })
            
            return pd.DataFrame(superposiciones)
        
        # Detectar superposiciones en los datos filtrados
        df_superposiciones = detectar_superposiciones(df_gerencial)
        
        if not df_superposiciones.empty:
            # Métricas de superposiciones
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                medicos_con_conflictos = df_superposiciones['medico'].nunique()
                st.metric("Médicos con conflictos", medicos_con_conflictos)
            
            with col2:
                total_conflictos = len(df_superposiciones)
                st.metric("Total conflictos", total_conflictos)
            
            with col3:
                conflictos_mismo_centro = len(df_superposiciones[df_superposiciones['tipo_conflicto'] == 'Mismo centro'])
                st.metric("Conflictos mismo centro", conflictos_mismo_centro)
            
            with col4:
                conflictos_centros_diferentes = len(df_superposiciones[df_superposiciones['tipo_conflicto'] == 'Centros diferentes'])
                st.metric("Conflictos entre centros", conflictos_centros_diferentes)
            
            # Tabla de conflictos
            st.subheader("Detalle de conflictos de horarios")
            
            # Aplicar colores según el tipo de conflicto
            def color_conflictos(val):
                if val == 'Mismo centro':
                    return 'background-color: #ffebee'  # Rojo claro
                elif val == 'Centros diferentes':
                    return 'background-color: #fff3e0'  # Naranja claro
                return ''
            
            # Renombrar columnas para mejor visualización
            df_superposiciones_display = df_superposiciones.rename(columns={
                'medico': 'Médico',
                'dia': 'Día',
                'centro_1': 'Centro 1',
                'area_1': 'Área 1',
                'horario_1': 'Horario 1',
                'tipo_agenda_1': 'Tipo Agenda 1',
                'centro_2': 'Centro 2',
                'area_2': 'Área 2',
                'horario_2': 'Horario 2',
                'tipo_agenda_2': 'Tipo Agenda 2',
                'tipo_conflicto': 'Tipo de conflicto'
            })
            
            st.dataframe(
                df_superposiciones_display,
                use_container_width=True,
                height=400
            )
            
            # Resumen por médico
            st.subheader("Resumen de conflictos por médico")
            resumen_conflictos = df_superposiciones.groupby('medico').agg({
                'dia': lambda x: ', '.join(sorted(set(x))),
                'tipo_conflicto': lambda x: ', '.join(set(x))
            }).rename(columns={
                'dia': 'Días con conflictos',
                'tipo_conflicto': 'Tipos de conflicto'
            })
            resumen_conflictos['Total conflictos'] = df_superposiciones['medico'].value_counts()
            
            # Agregar información de tipos de agenda para cada médico con conflictos
            tipos_agenda_por_medico = df_gerencial[df_gerencial['doctor'].isin(df_superposiciones['medico'].unique())].groupby('doctor')['tipo_turno'].apply(lambda x: ', '.join(sorted(set(x)))).to_dict()
            resumen_conflictos['Tipos de agenda'] = resumen_conflictos.index.map(tipos_agenda_por_medico)
            
            st.dataframe(resumen_conflictos, use_container_width=True)
            
            # Gráfico de conflictos por día
            if len(df_superposiciones) > 0:
                conflictos_por_dia = df_superposiciones['dia'].value_counts()
                
                fig_conflictos = px.bar(
                    x=conflictos_por_dia.index,
                    y=conflictos_por_dia.values,
                    title="Conflictos de horarios por día de la semana",
                    labels={'x': 'Día', 'y': 'Número de conflictos'},
                    color=conflictos_por_dia.values,
                    color_continuous_scale='Reds'
                )
                fig_conflictos.update_layout(height=400, showlegend=False)
                st.plotly_chart(fig_conflictos, use_container_width=True)
            
        else:
            st.success("No se detectaron conflictos de horarios en los datos filtrados.")
            st.info("Todos los médicos tienen horarios sin superposiciones.")

# TAB 8: CONTROL DE CALIDAD
with tab8:
    st.header("Control de calidad de datos")
    
    # Verificar si existe la columna agenda_id
    if 'agenda_id' in df.columns:
        # Métricas generales
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            total_registros = len(df_filtrado)
            st.metric("Total registros", total_registros)
        
        with col2:
            agendas_unicas_id = df_filtrado['agenda_id'].nunique()
            st.metric("Agendas únicas (ID)", agendas_unicas_id)
        
        with col3:
            agendas_unicas_nombre = df_filtrado['nombre_original_agenda'].nunique()
            st.metric("Nombres únicos", agendas_unicas_nombre)
        
        with col4:
            duplicados_detectados = agendas_unicas_id - agendas_unicas_nombre
            if duplicados_detectados > 0:
                st.metric("Duplicados detectados", duplicados_detectados, delta=f"+{duplicados_detectados}")
            else:
                st.metric("Duplicados detectados", duplicados_detectados)

        st.markdown("---")
        
        # Análisis de duplicados
        st.subheader("Análisis de agendas duplicadas")
        
        # Encontrar agendas con el mismo nombre pero diferentes IDs
        nombre_counts = df_filtrado.groupby(['nombre_original_agenda', 'efector']).agg({
            'agenda_id': 'nunique'
        }).reset_index()
        
        duplicados = nombre_counts[nombre_counts['agenda_id'] > 1]
        
        if len(duplicados) > 0:
            st.warning(f"Se encontraron {len(duplicados)} agendas con nombres duplicados en el mismo centro:")
            
            for _, row in duplicados.iterrows():
                nombre_agenda = row['nombre_original_agenda']
                efector = row['efector']
                num_duplicados = row['agenda_id']
                
                st.write(f"**{efector}**")
                st.write(f"Agenda: `{nombre_agenda}`")
                st.write(f"Instancias: {num_duplicados}")
                
                # Mostrar los IDs específicos
                ids_agenda = df_filtrado[
                    (df_filtrado['nombre_original_agenda'] == nombre_agenda) & 
                    (df_filtrado['efector'] == efector)
                ]['agenda_id'].unique()
                
                st.write(f"IDs: {', '.join(ids_agenda)}")
                
                # Mostrar tabla detallada de estas agendas duplicadas
                df_duplicado = df_filtrado[
                    (df_filtrado['nombre_original_agenda'] == nombre_agenda) & 
                    (df_filtrado['efector'] == efector)
                ].groupby(['agenda_id', 'dia']).agg({
                    'hora_inicio': 'first',
                    'hora_fin': 'first',
                    'doctor': 'first',
                    'area': 'first'
                }).reset_index()
                
                st.dataframe(
                    df_duplicado.rename(columns={
                        'agenda_id': 'ID de agenda',
                        'dia': 'Día',
                        'hora_inicio': 'Hora inicio',
                        'hora_fin': 'Hora fin',
                        'doctor': 'Médico',
                        'area': 'Área'
                    }),
                    use_container_width=True,
                    hide_index=True
                )
                st.markdown("---")
        else:
            st.success("No se detectaron agendas duplicadas en los datos filtrados.")
        
        # Análisis por centro
        st.subheader("Análisis por centro de salud")
        
        resumen_centros = df_filtrado.groupby('efector').agg({
            'agenda_id': 'nunique',
            'nombre_original_agenda': 'nunique'
        }).reset_index()
        
        resumen_centros['duplicados'] = resumen_centros['agenda_id'] - resumen_centros['nombre_original_agenda']
        resumen_centros = resumen_centros.sort_values('duplicados', ascending=False)
        
        st.dataframe(
            resumen_centros.rename(columns={
                'efector': 'Centro de salud',
                'agenda_id': 'Agendas únicas (ID)',
                'nombre_original_agenda': 'Nombres únicos',
                'duplicados': 'Duplicados'
            }),
            use_container_width=True,
            hide_index=True
        )
        
        # Gráfico de duplicados por centro
        fig_duplicados = px.bar(
            resumen_centros[resumen_centros['duplicados'] > 0],
            x='efector',
            y='duplicados',
            title='Duplicados por centro de salud',
            labels={'efector': 'Centro de salud', 'duplicados': 'Número de duplicados'}
        )
        fig_duplicados.update_layout(xaxis_tickangle=-45)
        st.plotly_chart(fig_duplicados, use_container_width=True)
        
    else:
        st.error("La columna 'agenda_id' no está disponible en los datos.")
        st.info("Para usar esta funcionalidad, reprocesa los datos con la versión actualizada del sistema.")

with tab9:
    st.header("Sin asignar")
    st.markdown("Análisis de agendas con campos faltantes o sin asignar")
    
    # Selector de campo a analizar
    campos_disponibles = {
        'doctor': 'Médico',
        'area': 'Área/Especialidad', 
        'tipo_turno': 'Tipo de turno',
        'dia': 'Día',
        'hora_inicio': 'Hora inicio',
        'hora_fin': 'Hora fin'
    }
    
    campo_seleccionado = st.selectbox(
        "Selecciona el campo a analizar:",
        list(campos_disponibles.keys()),
        format_func=lambda x: campos_disponibles[x]
    )
    
    # Definir qué valores se consideran "sin asignar" para cada campo
    valores_sin_asignar = {
        'doctor': ['Sin asignar', '', 'nan', None],
        'area': ['Sin área', '', 'nan', None],
        'tipo_turno': ['No especificado', '', 'nan', None],
        'dia': ['', 'nan', None],
        'hora_inicio': ['', 'nan', None],
        'hora_fin': ['', 'nan', None]
    }
    
    # Filtrar registros sin asignar para el campo seleccionado
    valores_faltantes = valores_sin_asignar[campo_seleccionado]
    
    # Crear máscara para valores faltantes
    mask_sin_asignar = df_filtrado[campo_seleccionado].isin(valores_faltantes) | \
                      df_filtrado[campo_seleccionado].isna() | \
                      (df_filtrado[campo_seleccionado].astype(str).str.strip() == '')
    
    df_sin_asignar = df_filtrado[mask_sin_asignar]
    
    # Métricas
    col1, col2, col3 = st.columns(3)
    
    with col1:
        total_sin_asignar = len(df_sin_asignar)
        total_registros = len(df_filtrado)
        porcentaje = (total_sin_asignar / total_registros * 100) if total_registros > 0 else 0
        st.metric(
            f"Registros sin {campos_disponibles[campo_seleccionado].lower()}", 
            total_sin_asignar,
            f"{porcentaje:.1f}% del total"
        )
    
    with col2:
        agendas_afectadas = df_sin_asignar['nombre_original_agenda'].nunique()
        st.metric("Agendas afectadas", agendas_afectadas)
    
    with col3:
        efectores_afectados = df_sin_asignar['efector'].nunique()
        st.metric("Centros afectados", efectores_afectados)
    
    if not df_sin_asignar.empty:
        # Análisis por efector
        st.subheader(f"Distribución por centro de salud")
        
        resumen_efector = df_sin_asignar.groupby('efector').agg({
            'nombre_original_agenda': 'nunique',
            campo_seleccionado: 'count'
        }).reset_index()
        resumen_efector = resumen_efector.rename(columns={
            'efector': 'Centro de salud',
            'nombre_original_agenda': 'Agendas afectadas',
            campo_seleccionado: 'Registros sin asignar'
        }).sort_values('Registros sin asignar', ascending=False)
        
        # Gráfico de barras
        fig_efector = px.bar(
            resumen_efector,
            x='Centro de salud',
            y='Registros sin asignar',
            title=f'Registros sin {campos_disponibles[campo_seleccionado].lower()} por centro',
            color='Registros sin asignar',
            color_continuous_scale='reds'
        )
        fig_efector.update_layout(xaxis_tickangle=-45, height=400)
        st.plotly_chart(fig_efector, use_container_width=True)
        
        st.dataframe(resumen_efector, use_container_width=True, hide_index=True)
        
        # Tabla detallada de agendas sin asignar
        st.subheader(f"Detalle de agendas sin {campos_disponibles[campo_seleccionado].lower()}")
        
        # Preparar columnas para mostrar
        columnas_mostrar = ['nombre_original_agenda', 'efector', 'dia', 'hora_inicio', 'hora_fin']
        if campo_seleccionado not in columnas_mostrar:
            columnas_mostrar.append(campo_seleccionado)
        
        # Agregar otras columnas relevantes
        for col in ['doctor', 'area', 'tipo_turno']:
            if col != campo_seleccionado and col not in columnas_mostrar:
                columnas_mostrar.append(col)
        
        df_detalle = df_sin_asignar[columnas_mostrar].drop_duplicates()
        
        # Renombrar columnas para mejor presentación
        df_detalle_renamed = df_detalle.rename(columns={
            'nombre_original_agenda': 'Nombre original de agenda',
            'efector': 'Centro de salud',
            'dia': 'Día',
            'hora_inicio': 'Hora inicio',
            'hora_fin': 'Hora fin',
            'doctor': 'Médico',
            'area': 'Área',
            'tipo_turno': 'Tipo de turno'
        })
        
        # Filtros adicionales para la tabla
        st.markdown("**Filtros para la tabla:**")
        col_filter1, col_filter2 = st.columns(2)
        
        with col_filter1:
            efectores_unicos = ['Todos'] + sorted(df_sin_asignar['efector'].unique().tolist())
            efector_filtro = st.selectbox(
                "Filtrar por centro:",
                efectores_unicos,
                key="filtro_efector_sin_asignar"
            )
        
        with col_filter2:
            if campo_seleccionado != 'area':
                areas_sin_asignar = ['Todas'] + sorted(df_sin_asignar['area'].dropna().unique().tolist())
                area_filtro = st.selectbox(
                    "Filtrar por área:",
                    areas_sin_asignar,
                    key="filtro_area_sin_asignar"
                )
            else:
                area_filtro = 'Todas'
        
        # Aplicar filtros a la tabla
        df_tabla_filtrada = df_detalle_renamed.copy()
        
        if efector_filtro != 'Todos':
            df_tabla_filtrada = df_tabla_filtrada[df_tabla_filtrada['Centro de salud'] == efector_filtro]
        
        if area_filtro != 'Todas' and campo_seleccionado != 'area':
            df_tabla_filtrada = df_tabla_filtrada[df_tabla_filtrada['Área'] == area_filtro]
        
        # Mostrar la tabla
        st.dataframe(
            df_tabla_filtrada,
            use_container_width=True,
            hide_index=True
        )
        
        # Botón para descargar
        if st.button(f"Descargar registros sin {campos_disponibles[campo_seleccionado].lower()}"):
            csv = df_tabla_filtrada.to_csv(index=False)
            st.download_button(
                label="Descargar CSV",
                data=csv,
                file_name=f"registros_sin_{campo_seleccionado}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                mime="text/csv"
            )
    
    else:
        st.success(f"No se encontraron registros sin {campos_disponibles[campo_seleccionado].lower()} con los filtros aplicados.")

